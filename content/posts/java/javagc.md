---
title: "Java内存回收"
date: 2020-04-16T11:07:57+08:00
draft: true
description: 跑得好好的Java进程，怎么突然就瘫痪了？
categories: ["Java","内存"]
tags : ["Java","内存"]
featured_image:
author: "ipoo"
---

<!-- MarkdownTOC -->

- [跑得好好的Java进程，怎么突然就瘫痪了？](#%E8%B7%91%E5%BE%97%E5%A5%BD%E5%A5%BD%E7%9A%84java%E8%BF%9B%E7%A8%8B%EF%BC%8C%E6%80%8E%E4%B9%88%E7%AA%81%E7%84%B6%E5%B0%B1%E7%98%AB%E7%97%AA%E4%BA%86%EF%BC%9F)
	- [内存回收一直是java的痛点](#%E5%86%85%E5%AD%98%E5%9B%9E%E6%94%B6%E4%B8%80%E7%9B%B4%E6%98%AFjava%E7%9A%84%E7%97%9B%E7%82%B9)
	- [为什么fgc停不下来了](#%E4%B8%BA%E4%BB%80%E4%B9%88fgc%E5%81%9C%E4%B8%8D%E4%B8%8B%E6%9D%A5%E4%BA%86)
	- [如何让系统fgc之后仍然能活下来](#%E5%A6%82%E4%BD%95%E8%AE%A9%E7%B3%BB%E7%BB%9Ffgc%E4%B9%8B%E5%90%8E%E4%BB%8D%E7%84%B6%E8%83%BD%E6%B4%BB%E4%B8%8B%E6%9D%A5)

<!-- /MarkdownTOC -->



# 跑得好好的Java进程，怎么突然就瘫痪了？

> 简介： 你是否有过这样的经历，跑得好好的Java进程，突然就瘫痪了。过于依赖Java虚拟机导致我们对问题无从下手，问题反复出现影响开发效率。其实，多数Java进程瘫痪的原因可以从java虚拟机层面找到原因，本文列举出导致Java进程瘫痪的一些共性原因，供大家交流和学习。
> 
Java能成为应用最广泛的语言，和他的内存托管机制是分不开的。很多人眼中，Java虚拟机是透明的，只需知道核心api的用法，便可以专注于实现具体业务，然后依赖Java虚拟机运行甚至优化应用。
你是否有过这样的经历，跑得好好的Java进程，突然就瘫痪了。过于依赖Java虚拟机导致我们对问题无从下手，问题反复出现影响开发效率。其实，多数Java进程瘫痪的原因可以从java虚拟机层面找到原因，
本文列举出导致Java进程瘫痪的一些共性原因，供大家交流和学习。

## 内存回收一直是java的痛点
用Java无法做出类似Redis这样的产品。java的内存回收机制使我们在编写代码时不需要关注对象的回收，同时加大了内存回收的消耗，标记复制需要做内存拷贝，标记清除算法则需要stop the world。所以我们在使用缓存的时候，量稍微大一些就需要借助类似Redis这样的中间件帮我们处理了。作为Javaer，我们享受了自动内存回收的安逸，同时也需要多了解下内存优化的方法。
## 为什么fgc停不下来了
1. 什么情况下会gc

为了了解我们的系统为什么会不停fgc，我们需要先了解一下系统什么情况下会gc。在jvm层面，当我们new一个对象的时候，jvm会先在堆区分配对象需要的内存，这个时候如果内存不够的话，就需要gc了，gc的返回结果就是对象的空间地址。jvm会先进行ygc，也就是我们通常说的标记复制，如果ygc之后依然申请不到空间，就会进行fgc了。同理，如果fgc之后依然没有足够的空间，就会循环的进行fgc，直到申请到足够的空间。
2. 导致不停的fgc的原因

如上文所讲，fgc有可能发生在你的每一行代码。如果fgc之后依然没有足够的空间，就会不停的fgc，直到申请到足够的空间。同时JVM会限制在抛出OutOfMemory错误之前在GC中花费的VM时间的比例。
系统频繁FGC大致有五种情况：
- 内存泄漏
- 请求处理变慢导致同时申请内存的线程太多
- metaspace 耗尽
- 常量池将堆区占满
- 堆外内存耗尽

1w，正常情况下处理一个请求的时间是1ms，那同一时刻并行的请求数量仅为10。如果性能发生抖动，每个请求处理的时间增加到100ms，那同一时刻并行的请求数量就会增加到100个。每个线程在处理请求的时候都会new一些对象出来，长时间存活的线程会造成类似内存泄漏的效果，将系统的内存耗尽。同时fgc也会加剧系统性能的开销，使系统变得更慢，产生雪崩。

## 如何让系统fgc之后仍然能活下来
1. 杜绝内存泄漏

内存泄漏造成系统瘫痪的频率很高，有些系统定时从数据库拉取配置信息缓存到集合中，但是set不小心写成了list，最终在新增元素的时候内存溢出了。养成良好的编程习惯，多关注些细节，就能避免很多未知的问题。

2. 并发限制：防止系统被撑死

每台服务器都有并行处理请求的上限，不管请求处理的多快，超过上限之后就会被撑死，对高并发的请求做好并发数限制是保持系统稳定的必要条件。需要注意的是，有一些系统在拒绝过多的请求时，也会做一些降级逻辑，降级逻辑也是有性能开销的，同样需要做并发限制，如果降级的请求超过并发限制，将不进行降级逻辑直接抛出异常。我们可使用的限流组件有很多，推荐我们阿里自研的Sentinel 和 Netflix开源的Hystrix。

3. 自适应限流：防止系统被摸死

我们需要自适应限流有两个原因：

- 每台服务器所处的环境是不一样的

有些服务器和离线计算的vm混部在一起，有些部署在实体机，有些部署在新老型号的机器上，每台服务器能承受的qps并不完全一样。统一配置分布式系统中每台服务器限流阀值，要么发挥不出每台服务器应有的作用，要么在高qps的情况下一些比较慢的服务器宕机，所以用服务器作为限流粒度是最合适的。


- 设置了正确的限流阀值，也可能被摸死

当单机承受的QPS 6~20倍于限流的流量时，拒绝一次请求的开销就无法忽略不记了。譬如春晚活动有些系统设置了正确的限流也被6~20倍于限流的流量冲垮。这种死法称为被摸死。应对这种情况，我们可以做的是在受到6~20倍的大流量时，动态减少限流的阀值。比如系统最开始接受1000qps，5000的拒绝流量过来会把系统摸死，这个时候我们调整系统的阀值，限流设置到100，被摸死的阀值就可以高一些，这样就算有6000个请求进来，我们系统也可以保证活下来。

4. 异常流量监控：防止长尾请求拖垮系统

我们盯系统监控的时候通常会关注99分位的数据，但如果设置了合理的限流，系统依然被流量打挂，就要从那百分之一的长尾数据入手了。有些长尾数据对系统的影响会非常大。想象如果一个put请求传过来几十兆的数据，对java是极为不友好的，很有可能产生fgc，让请求变慢，导致一系列问题。
总之，磨刀不误砍柴工，当我们的系统因为fgc一次又一次重启的时候，不如花时间了解下系统产生性能问题的原因，将产生问题的那根针拔掉，晚上睡个安稳觉，白天更加充满活力的挖新坑。希望每个程序员手里都是一个稳定的系统。

> 参考资料：[jvm调优总结](hllvm-group.iteye.com/group/wiki/?spm=a2c6h.12873639.0.0.361626b43IpNo7&category_id=301)






**有帮助请留言...**

<!-- 
扫码关注公众号《ipoo》
![ipoo](http://oss.ipooli.com/images/%E5%85%AC%E4%BC%97%E5%8F%B7code.jpg) -->